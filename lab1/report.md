# **实验报告：Lab1 - 最小可执行内核**

## 摘要

本实验旨在构建一个最小化的、可在 QEMU RISC-V 64位模拟环境中运行的操作系统内核。实验的核心目标是深入理解操作系统从硬件加电到内核主函数执行的完整启动链条。通过本次实验，我们成功地：1) 使用链接脚本（Linker Script）精确定义了内核的内存布局和程序入口点；2) 实现了从底层汇编代码到C语言环境的切换，并正确设置了内核栈；3) 利用 OpenSBI 固件提供的 `ecall` 服务封装了基本的控制台输出功能；4) 掌握了使用 GDB 对 QEMU 环境下的内核进行源码级调试的方法，并实际跟踪验证了从复位向量 `0x1000` 到内核入口 `0x80200000` 的完整启动流程。

## 1\. 实验背景与目的

现代操作系统内核如 Linux 代码量已达数百万行，直接学习的难度极大。本系列实验采用“麻雀虽小，五脏俱全”的思想，从一个仅能打印信息的“麻雀骨架”开始，逐步为其添加功能，最终构建一个微型操作系统。Lab1 作为系列实验的基石，其主要目的包括：

  * **理解启动流程：** 掌握计算机从加电复位，经由固件（OpenSBI），到加载并跳转执行操作系统内核的完整过程。
  * **掌握内存布局：** 学习使用链接脚本来控制程序的内存布局，理解代码段、数据段、BSS段等的组织方式，并指定内核的加载基址和入口点。
  * **掌握底层接口：** 了解 RISC-V 架构下的特权级概念，并通过 `ecall` 指令调用 M 模式的 OpenSBI 服务，实现最基础的I/O操作。
  * **熟悉调试工具：** 学会配置 QEMU 和 GDB 进行远程调试，为后续更复杂的内核开发打下坚实基础。

## 2\. 实验环境

  * **硬件平台：** QEMU 模拟的 RISC-V 64位 virt 虚拟开发板
  * **软件工具：** RISC-V GCC 交叉编译工具链, GNU Make, QEMU, GDB (riscv64-unknown-elf-gdb)
  * **核心固件：** OpenSBI

## 3\. 实验原理与设计

### 3.1. 内核启动链

最小内核的启动是一个“接力”过程，涉及多个阶段和组件：

1.  **QEMU 加电复位：** QEMU 模拟 CPU 上电，程序计数器（PC）被强制设置为复位地址 `0x1000`。
2.  **MROM 执行：** CPU 从 `0x1000` 处执行一段固化的引导代码，其主要任务是进行最基础的硬件初始化，并将控制权交给 OpenSBI。
3.  **OpenSBI 初始化：** OpenSBI 固件被加载到 `0x80000000`，它运行在最高特权级 M-Mode。它负责设置 S-Mode 的运行环境（如异常委托），并将我们的内核镜像（`ucore.img`）从模拟磁盘加载到物理内存地址 `0x80200000`。
4.  **内核接管：** OpenSBI 完成任务后，通过一条跳转指令，将 CPU 的控制权交给 `0x80200000`，即我们的内核入口点。

### 3.2. 链接脚本与内存布局

为了让 OpenSBI 能正确跳转到我们的内核，我们必须确保内核的第一条指令位于 `0x80200000`。这通过链接脚本 `tools/kernel.ld` 实现：

  * `BASE_ADDRESS = 0x80200000;`: 定义了内核的链接基地址。
  * `ENTRY(kern_entry);`: 指定 `kern_entry` 这个符号为程序的入口点。
  * `SECTIONS {...}`: 精确地将输入目标文件的 `.text`, `.rodata`, `.data`, `.bss` 等段按顺序组织到最终的 ELF 文件中，确保了代码和数据的地址正确性。

### 3.3. 从 SBI 到 `cprintf`

内核在启动初期无法依赖任何标准库。为了实现格式化输出 `cprintf`，我们构建了一个调用栈：

1.  **`cprintf()`:** 格式化字符串。
2.  **`cons_putc()`:** 输出单个字符。
3.  **`sbi_console_putchar()`:** 调用通用的 SBI 服务函数。
4.  **`sbi_call()`:** 这是核心封装。它使用 `__asm__ volatile` 内联汇编，将 SBI 功能号（如 `SBI_CONSOLE_PUTCHAR`）和参数放入指定寄存器 (`a7`, `a0` 等)，然后执行 `ecall` 指令。`ecall` 会使 CPU 从 S-Mode陷入 M-Mode，由 OpenSBI 处理请求，最终在控制台打印字符。

## 4\. 实验过程与结果分析

### 4.1. 练习1：理解内核启动中的程序入口操作

#### **问题描述**

阅读 `kern/init/entry.S`，说明指令 `la sp, bootstacktop` 和 `tail kern_init` 的作用与目的。

#### **代码分析**

```asm
# kern/init/entry.S
.section .text.kern_entry,"ax",@progbits 
.globl kern_entry
kern_entry: 
    la sp, bootstacktop  # 加载内核栈顶地址到 sp 寄存器
    tail kern_init       # 无返回跳转到 kern_init 函数

.section .data
.align 12
.global bootstack
bootstack:
    .space 4096 * 4
.global bootstacktop
bootstacktop:
```

#### **结果与分析**

  * **`la sp, bootstacktop`:**

      * **操作：** `la` (Load Address) 伪指令将符号 `bootstacktop` 的地址加载到 `sp` (Stack Pointer) 寄存器。`bootstacktop` 位于我们静态分配的 16KB 内核栈的最高地址处。
      * **目的：** 为即将执行的 C 语言代码建立一个有效的运行时栈。C 函数的调用、局部变量的分配都依赖于栈指针 `sp`。在执行这条指令前，`sp` 的值是 OpenSBI 使用的栈，内核不能继续使用。这是从汇编环境过渡到 C 环境的关键准备步骤。

  * **`tail kern_init`:**

      * **操作：** `tail` 是一条伪指令，通常被汇编器优化为一条无条件跳转指令 (`j kern_init`)。它直接跳转到 `kern_init` 函数的地址开始执行，并且不会在栈上保存返回地址（不像 `call` 指令）。
      * **目的：** 将 CPU 的控制权彻底地、单向地移交给内核的 C 语言入口函数 `kern_init`。因为 `kern_entry` 的使命已经完成，永远不需要返回，使用尾调用（tail call）/跳转是最高效的方式。

### 4.2. 练习2: 使用GDB验证启动流程

#### **问题描述**

使用 GDB 跟踪 QEMU 从加电到执行内核第一条指令的整个过程，回答 RISC-V 加电后执行的指令位置和功能。

#### **调试过程与观察**

1.  **启动与连接：** 按照实验指导，通过 `make debug` 和 `make gdb` 成功建立调试会话。
2.  **复位地址确认：** GDB 连接成功后，程序自动暂停。通过 `x/i $pc` 查看当前指令，确认 QEMU 模拟的 RISC-V CPU **加电后的起始地址为 `0x1000`**。
    ```
    (gdb) x/i 0x1000
    => 0x1000: auipc t0, 0x0
    ```
3.  **设置断点与观察点：** 设置断点 `b *0x80200000` 监控内核入口，设置观察点 `watch *0x80200000` 观察内核何时被加载。
4.  **执行与跳转：** 输入 `c` 继续执行。程序首先会触发观察点（说明 OpenSBI 正在加载内核），然后命中位于 `0x80200000` 的断点。
    ```
    Breakpoint 1, kern_entry () at kern/init/entry.S:10
    10      la sp, bootstacktop
    ```
5.  **寄存器状态分析：**
      * 在 `kern_entry` 断点处，查看 PC 和 SP 寄存器：
        > **PC = 0x80200000**, **SP = 0x8001bd80**
        > 此处的 `sp` 值是 OpenSBI 留下的，并非我们的内核栈。
      * 使用 `si` 命令单步执行 `la sp, bootstacktop` 指令后，再次查看 SP 寄存器：
        > **SP = 0x80203000**
        > `0x80203000` 正是 `bootstacktop` 的链接地址，这证明内核栈已成功建立。

#### **结果与分析**

调试结果清晰地验证了启动链：

1.  **硬件加电**后，CPU 从固定的复位地址 `0x1000` 开始执行。
2.  这段初始代码（MROM）的功能是**进行最基础的设置并跳转到 OpenSBI 固件**。
3.  **OpenSBI** 接管后，执行一系列**硬件初始化**（如设置 PMP 物理内存保护、配置 S 模式异常代理等），然后**将内核镜像加载到物理地址 `0x80200000`**。
4.  最后，OpenSBI 跳转到 `0x80200000`，**将控制权顺利移交给我们的内核**，GDB 断点被触发，内核开始执行。

## 5\. 实验总结

| 实验知识点 | 对应的操作系统原理 | 理解与关系 |
| :--- | :--- | :--- |
| **Bootloader/OpenSBI** | 操作系统引导（Booting） | 实验中的 OpenSBI 扮演了 Bootloader 的角色，是运行在更高特权级（M-Mode）的固件。它负责初始化底层硬件，加载内核到内存，并最终将控制权转交给内核，这是所有操作系统启动的第一步。 |
| **链接脚本与内存布局** | 程序的装载与内存模型 | 链接脚本是编译链接阶段的“蓝图”。通过指定基地址和入口点，我们确保了地址相关代码能够被正确加载和执行。这对应了 OS 原理中，加载器（Loader）如何根据可执行文件的元信息将其放置到内存的正确位置。 |
| **栈初始化** | 函数调用栈与 ABI | 在 `entry.S` 中手动设置 `sp` 寄存器，是遵循 RISC-V ABI（应用二进制接口）规范的体现。它为 C 语言函数调用准备了必要的栈空间，是理解高级语言底层运行机制的基础。 |
| **SBI 与 `ecall`** | 特权级切换与系统调用 | 实验中从 S-Mode 通过 `ecall` 调用 M-Mode 的 SBI 服务，完美地展示了受控的特权级提升机制。这与用户态程序通过 `ecall`（即系统调用）请求内核态服务的原理完全相同，是操作系统提供服务的核心机制。 |

### **原理与实践的差异**

本实验极大地简化了真实世界的启动过程。例如，我们没有涉及设备发现（如 PCI 扫描）、多核处理器（SMP）的启动、复杂的内存探测等。此外，OS 原理中许多核心概念，如**虚拟内存、进程/线程调度、文件系统、中断处理**等，在这个最小内核中均未体现，这些将在后续实验中逐步实现。

## 6\. 结论

通过本次实验，我们成功构建并运行了一个最小化的 RISC-V 内核。我们不仅学习了内核编译、链接和加载的实践技术，更重要的是，通过 GDB 调试，我们亲眼见证并验证了从硬件复位到内核代码执行的每一步关键转换。这为我们深刻理解操作系统与底层硬件的交互、特权级的工作模式以及程序运行环境的构建打下了坚实的基础。