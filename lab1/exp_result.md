# Lab1 实验结果记录

## 第一阶段：理论学习记录

- **实验目标总结：** 构建最小可执行 RISC-V 内核，理解从上电到内核接管（OpenSBI→内核）的启动链条；掌握链接脚本内存布局、入口点设定，以及通过 OpenSBI 封装基础 I/O 的方法。
- **关键文件作用：**
  - `kern/init/entry.S`: 汇编入口，建立内核栈并无返回跳转到 `kern_init`。
  - `kern/init/init.c`: C 入口，清零 `.bss`、输出启动信息并进入死循环。
  - `tools/kernel.ld`: 链接脚本，设定 `BASE_ADDRESS=0x80200000`，入口 `ENTRY(kern_entry)`，组织各段布局。
  - `libs/sbi.c`: 封装 `sbi_call`（通过 `ecall` 触发 OpenSBI 服务），提供字符输出等基础能力。

## 第二阶段：代码分析与运行记录

- **链接脚本分析 (`kernel.ld`):**
  - `BASE_ADDRESS` 的作用是将输出镜像的装载/链接基址设为 `0x80200000`，确保内核第一条指令与数据段的绝对地址符合 QEMU/OpenSBI 预期的加载位置。
  - `ENTRY(kern_entry)` 的作用是指定程序入口符号，链接器据此设置 ELF 入口，使 CPU 从该符号处开始执行（经由固件跳转）。

- **练习1：理解内核启动中的程序入口操作**
  - 指令 `la sp, bootstacktop` 完成的操作是将栈指针 `sp` 设为内核栈顶符号地址，使后续 C 调用拥有有效的栈空间；目的是建立函数调用所需的运行时栈环境（栈向低地址增长）。
  - 指令 `tail kern_init` 完成的操作是无返回跳转到 `kern_init`（尾调用优化），不保存返回地址，直接将控制权移交给 C 入口；目的是从汇编入口切换到 C 初始化逻辑。

- **`make qemu` 的终端输出结果：**
```
OpenSBI v0.4 (Jul  2 2019 11:53:53)
   ____                    _____ ____ _____
  / __ \                  / ____|  _ \_   _|
 | |  | |_ __   ___ _ __ | (___ | |_) || |
 | |  | | '_ \ / _ \ '_ \ \___ \|  _ < | |
 | |__| | |_) |  __/ | | |____) | |_) || |_
  \____/| .__/ \___|_| |_|_____/|____/_____|
        | |
        |_|

Platform Name          : QEMU Virt Machine
Platform HART Features : RV64ACDFIMSU
Platform Max HARTs     : 8
Current Hart           : 0
Firmware Base          : 0x80000000
Firmware Size          : 112 KB
Runtime SBI Version    : 0.1

PMP0: 0x0000000080000000-0x000000008001ffff (A)
PMP1: 0x0000000000000000-0xffffffffffffffff (A,R,W,X)
(THU.CST) os is loading ...
```

## 第三阶段：GDB 调试记录

- **练习2: 使用GDB验证启动流程**
- **调试过程简述：**
  - 终端A：`make debug` 启动 QEMU（`-s -S`，暂停等待 GDB）。
  - 终端B：GDB 连接：`file bin/kernel`, `set arch riscv:rv64`, `target remote localhost:1234`。
  - 记录复位地址处指令：`x/i 0x1000`。
  - 设置观察点与断点：`watch *0x80200000`，`b *0x80200000`，`c`。
  - 在 `kern_entry` 命中后：`info registers pc sp`，`x/i $pc`，`si` 一步，`info registers sp`。

- **观察结果：**
  - RISC-V 硬件加电后，GDB 暂停的第一条指令位于什么地址？
    > 答：0x1000（`auipc t0, 0x0` 显示在该地址处）
  - OpenSBI 在跳转到 `0x80200000` 之前，主要完成了哪些功能？(根据文档和调试推测)
    > 答：完成 M 模式固件初始化（基础硬件/委派寄存器/内存区保护等）、准备运行环境，并将内核镜像装载到物理地址 `0x80200000`，随后将控制权转交给内核入口。
  - 断点命中 `kern_entry` 后，使用 `i r pc sp` 命令观察到的 PC 和 SP 寄存器的值是多少？
    > 答：PC = 0x80200000, SP = 0x8001bd80
  - 执行完 `la sp, bootstacktop` 后，再次使用 `i r sp` 观察到的 SP 寄存器的值是多少？
    > 答：SP = 0x80203000

## 实验总结与思考

- **本实验中重要的知识点 (与OS原理的对应)：**
- **知识点1 (实验):** Bootloader/OpenSBI
- **对应原理:** 操作系统引导流程（固件→内核的控制权交接）
- **理解与关系:** 固件在更高特权级初始化硬件并加载内核，随后跳转至内核入口，完成控制权移交。

- **知识点2 (实验):** 链接脚本与内存布局
- **对应原理:** 程序装载与段布局
- **理解与关系:** 通过 `ENTRY` 与基地址，确保入口与各段在期望的物理地址，满足地址相关代码的运行前提。

- **知识点3 (实验):** 栈初始化与函数调用约定
- **对应原理:** 调用栈与 ABI
- **理解与关系:** 入口处建立内核栈，遵循 RISC-V 调用约定为 C 代码执行提供栈空间。

- **知识点4 (实验):** SBI 调用封装
- **对应原理:** 特权级切换与系统调用机制
- **理解与关系:** 通过 `ecall` 在 S→M 模式间受控切换，获取最基础的 I/O 能力。

- **OS原理中很重要，但实验中未体现的知识点：**
- 进程/线程调度、地址空间与虚拟内存、文件系统、系统调用子系统（U→S）、同步与中断、设备驱动框架等。


