

# 🧠 Buddy System Physical Memory Manager

**作者**：2313896 黄俊雄
**文件**：`kern/mm/buddy_system_pmm.c` / `kern/mm/buddy_system_pmm.h`
**日期**：2025 年
**所属模块**：内核物理内存管理（PMM）

---

## 📘 概述

本模块实现了一个基于 **伙伴系统（Buddy System）** 的物理内存分配器，用于操作系统内核的物理页管理。

该分配器以 **2 的幂次块（power-of-two blocks）** 为单位管理物理内存，并通过二叉树结构维护空闲块信息，实现高效的：

* ✅ **分配**：在 O(log n) 时间内找到最小合适块
* ✅ **释放**：自动与伙伴块合并，减少外部碎片
* ✅ **诊断**：通过调试函数可视化伙伴树层级状态

---

## 🧩 算法原理

### 1️⃣ 核心思想

* 整个物理内存区域被组织成一个 **完全二叉树**。
* 每个节点代表一个 **2^k 页** 的块。
* 叶节点对应单页（1 页大小的块）。
* 每个节点记录当前子树中 **最大空闲块的大小**。

当分配或释放内存时，算法在树上自顶向下或自底向上更新 `longest[]` 数组。

---

### 2️⃣ 二叉树结构示意

以总页数 = 8 页为例：

```
           [8]          ← 根节点 (8页)
          /   \
       [4]     [4]      ← 第一层
      / \     / \
    [2][2] [2][2]       ← 第二层
   /\/\/\/\/\/\/\
 [1][1][1][1][1][1][1][1] ← 叶子节点
```

---

### 3️⃣ 分配流程

1. 将请求页数 `n` 向上取整到最近的 2 的幂次。
2. 从根节点开始查找能够容纳该大小的最小块。
3. 如果当前块太大，则递归分裂子节点。
4. 找到目标块后标记为 **已分配** (`longest[i] = 0`)。
5. 自下而上更新父节点的 `longest` 值。

---

### 4️⃣ 释放流程

1. 找到要释放的块在树中的索引。
2. 将该节点及子树标记为 **完全空闲**。
3. 自下而上检查左右子节点是否均空闲：

   * 若均空闲，则合并为更大的块。
4. 重复合并直到根节点或遇到非空闲节点为止。

---

## ⚙️ 数据结构定义

### `struct buddy_system`

| 字段名         | 含义                  |
| ----------- | ------------------- |
| `size`      | 总管理页数（必须为 2 的幂次）    |
| `longest`   | 二叉树数组，每个节点存储最大空闲块大小 |
| `base_page` | 管理区的基页指针            |
| `max_order` | 最大阶数（log₂(size)）    |

树结构规则：

* 根节点索引 = 0
* 左子节点：`2 * i + 1`
* 右子节点：`2 * i + 2`
* 父节点：`(i - 1) / 2`

---

## 🧮 关键函数说明

| 函数名                                              | 说明                  |
| ------------------------------------------------ | ------------------- |
| `buddy_init()`                                   | 初始化全局状态             |
| `buddy_init_memmap(struct Page *base, size_t n)` | 根据内存页初始化伙伴系统        |
| `buddy_alloc_pages(size_t n)`                    | 分配 n 页（自动向上取 2 的幂次） |
| `buddy_free_pages(struct Page *base, size_t n)`  | 释放 n 页并自动合并空闲块      |
| `buddy_nr_free_pages()`                          | 统计剩余空闲页数            |
| `buddy_check()`                                  | 自动测试与验证函数           |

---

## 🧰 调试辅助函数

| 函数                            | 功能                      |
| ----------------------------- | ----------------------- |
| `print_buddy_levels()`        | 打印伙伴树每层状态（节点数、空闲块数、块大小） |
| `dump_buddy_state()`          | 输出当前伙伴系统全局信息            |
| `validate_tree_consistency()` | 验证树的逻辑一致性               |
| `set_subtree_full()`          | 递归将子树设为空闲状态             |
| `clear_subtree_zero()`        | 清除子树中所有已分配节点的空闲标志       |

---

## 🧪 测试用例

本模块包含完整的自检测试逻辑：

### ✅ `basic_buddy_check()`

验证基本分配与释放行为：

* 单页多次分配、分裂验证
* 单页逐步释放与伙伴合并
* 多页块（4页）分配与释放
* 树层级输出可视化验证

### ✅ `buddy_edge_case_test()`

验证边界与异常情况：

* 分配最大块（占满整个内存）
* 分配失败（内存耗尽）
* 全部释放后树恢复初始状态

---


## 🧱 错误处理机制

| 错误类型      | 检查点                           | 处理方式            |
| --------- | ----------------------------- | --------------- |
| 非 2 的幂次页数 | `fixsize()`                   | 自动向上取整          |
| 分配空间不足    | `buddy_alloc_pages()`         | 返回 `NULL` 并输出提示 |
| 非法释放地址    | `buddy_free_pages()`          | 调用 `panic()` 报错 |
| 树结构不一致    | `validate_tree_consistency()` | 触发断言            |

---

## 🧑‍💻 内核集成接口

本模块实现了标准的 `pmm_manager` 接口：

```c
const struct pmm_manager buddy_pmm_manager = {
    .name = "buddy_system_pmm_manager",
    .init = buddy_init,
    .init_memmap = buddy_init_memmap,
    .alloc_pages = buddy_alloc_pages,
    .free_pages = buddy_free_pages,
    .nr_free_pages = buddy_nr_free_pages,
    .check = buddy_check,
};
```

这使得该模块可以无缝替换 uCore 或其他 OS 实验框架中的默认物理页分配器。

---

## 🧠 设计优点总结

* 🚀 **高性能**：O(log n) 分配/释放
* 🧩 **自动合并**：减少碎片
* 🔍 **可视化调试输出**：辅助验证正确性
* 🧱 **接口标准化**：兼容 PMM 框架
* 💾 **容错机制完善**：边界检查与断言保护

---

## 🧪 测试结果汇总

| 测试项目         | 状态   |
| ------------ | ---- |
| 单页分配与释放      | ✅ 通过 |
| 多页分配与释放      | ✅ 通过 |
| 边界情况（最大块、耗尽） | ✅ 通过 |
| 树一致性检查       | ✅ 通过 |
| 空闲页统计        | ✅ 正确 |

---

## 📎 附录

### 🔢 层级状态统计格式

```
层 <level>: 节点数=<num_nodes>, 空闲块数=<free_blocks>, 每块大小=<block_size>页
```

例如：

```
层 3: 节点数=8, 空闲块数=6, 每块大小=2048页
```

---

### 🔍 调试建议

* 若释放后层级空闲数不恢复，应检查：

  * `set_subtree_full()` 是否递归正确；
  * `index_to_offset()` 与 `offset_to_index()` 的偏移映射；
  * 父节点合并条件中 `left_longest == right_longest == size/2` 是否触发。

---

**结论：**

> 本实现完全覆盖了伙伴系统的核心逻辑、树结构维护、空闲块合并、调试诊断与边界测试，是一个功能完备、性能优良的内核物理内存管理子系统。

---
