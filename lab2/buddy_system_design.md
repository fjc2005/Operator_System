

# 🧠 Buddy System Physical Memory Manager

**作者**：2313896 黄俊雄
**文件**：`kern/mm/buddy_system_pmm.c` / `kern/mm/buddy_system_pmm.h`
**日期**：2025 年
**所属模块**：内核物理内存管理（PMM）

---

## 📘 概述

本模块实现了一个基于 **伙伴系统（Buddy System）** 的物理内存分配器，用于操作系统内核的物理页管理。

该分配器以 **2 的幂次块（power-of-two blocks）** 为单位管理物理内存，并通过二叉树结构维护空闲块信息，实现高效的：

* ✅ **分配**：在 O(log n) 时间内找到最小合适块
* ✅ **释放**：自动与伙伴块合并，减少外部碎片
* ✅ **诊断**：通过调试函数可视化伙伴树层级状态

---

## 🧩 算法原理

### 1️⃣ 核心思想

* 整个物理内存区域被组织成一个 **完全二叉树**。
* 每个节点代表一个 **2^k 页** 的块。
* 叶节点对应单页（1 页大小的块）。
* 每个节点记录当前子树中 **最大空闲块的大小**。

当分配或释放内存时，算法在树上自顶向下或自底向上更新 `longest[]` 数组。

---

### 2️⃣ 二叉树结构示意

以总页数 = 8 页为例：

```
           [8]          ← 根节点 (8页)
          /   \
       [4]     [4]      ← 第一层
      / \     / \
    [2][2] [2][2]       ← 第二层
   /\/\/\/\/\/\/\
 [1][1][1][1][1][1][1][1] ← 叶子节点
```

---

### 3️⃣ 分配流程

1. 将请求页数 `n` 向上取整到最近的 2 的幂次。
2. 从根节点开始查找能够容纳该大小的最小块。
3. 如果当前块太大，则递归分裂子节点。
4. 找到目标块后标记为 **已分配** (`longest[i] = 0`)。
5. 自下而上更新父节点的 `longest` 值。

---

好的，遵照您的格式要求，这里是对代码中内存释放流程的详细解释。

### 4️⃣ 释放流程

在 buddy_free_pages 函数中，将一个已分配的内存块交还给系统的过程主要分为两个阶段：定位节点（自上而下）和合并伙伴（自下而上）。

1. 找到要释放的块在树中的索引

为了释放一个内存块，首先必须在表示内存的二叉树中找到代表这个块的确切节点。这个过程是通过内存块相对于整个管理区基地址的**偏移量（offset）**来完成的，具体步骤如下：

计算偏移量：通过 size_t offset = base - buddy_allocator->base_page; 计算出待释放页面 base 相对于起始页面的偏移量。

从根节点开始向下遍历：代码中的第一个 while 循环实现了这个逻辑。

从 index = 0 （根节点）开始，node_size 为总内存大小。

在每一层，通过 if (local_off < half) 判断偏移量是落在当前节点所代表内存区域的前半部分还是后半部分。

如果落在前半部分，则进入左子节点 (index = LEFT_LEAF(index))。

如果落在后半部分，则进入右子节点 (index = RIGHT_LEAF(index))，并更新局部偏移量 local_off -= half，使其变为相对于右子节点管理区域的新偏移。

这个过程不断重复，直到 node_size 等于要释放的块大小 size，此时的 index 就是目标节点。

2. 将该节点及子树标记为 完全空闲

找到目标节点后，需要更新树的状态以反映这块内存现在是空闲的。

buddy_allocator->longest[index] = size;：首先，将该节点自身的 longest 值设置为其代表的块大小，表示这个块现在是完全空闲的。

set_subtree_full(buddy_allocator, index, node_size);：接着，调用这个辅助函数，递归地将该节点下的所有子孙节点的 longest 值都恢复为它们各自代表的块大小。这确保了这部分子树恢复到了初始的、完全未被分配的状态。

3. 自下而上检查左右子节点是否均空闲

释放一个块后，它可能有一个同样是空闲的“伙伴”块。如果二者都空闲，它们就可以合并成一个更大的、位于上一层的父块。这个过程在代码的第二个 while (index) 循环中实现。

向上移动：index = PARENT(index); 将当前索引移动到父节点。

检查伙伴状态：通过 left_longest = buddy_allocator->longest[left]; 和 right_longest = buddy_allocator->longest[right]; 获取左右两个子节点的空闲空间大小。

合并条件：

if (left_longest == right_longest && left_longest == size / 2)：这是核心的合并判断。它检查左右两个子节点是否都已完全空闲（即它们的 longest 值都等于它们自身的大小）。

若均空闲，则合并为更大的块：如果条件满足，父节点的 longest 值被更新为它所代表的完整大小（buddy_allocator->longest[index] = size;），这标志着两个伙伴块成功合并。

4. 重复合并直到根节点或遇到非空闲节点为止

合并过程会持续向上进行。

在每次成功合并后，循环会继续移动到上一层父节点，再次尝试与新的伙伴块进行合并。

如果某一层中，一个节点的两个子节点没有同时处于完全空闲状态，则合并在该处停止。但父节点的 longest 值仍会被更新为 MAX(left_longest, right_longest)，以正确反映其子树中可用的最大连续内存块。

这个过程一直重复，直到抵达根节点（index 变为 0），或者合并过程因无法满足条件而中断。

## ⚙️ 数据结构定义

### `struct buddy_system`

| 字段名         | 含义                  |
| ----------- | ------------------- |
| `size`      | 总管理页数（必须为 2 的幂次）    |
| `longest`   | 二叉树数组，每个节点存储最大空闲块大小 |
| `base_page` | 管理区的基页指针            |
| `max_order` | 最大阶数（log₂(size)）    |

树结构规则：

* 根节点索引 = 0
* 左子节点：`2 * i + 1`
* 右子节点：`2 * i + 2`
* 父节点：`(i - 1) / 2`

---

## 🧮 关键函数说明

| 函数名                                              | 说明                  |
| ------------------------------------------------ | ------------------- |
| `buddy_init()`                                   | 初始化全局状态             |
| `buddy_init_memmap(struct Page *base, size_t n)` | 根据内存页初始化伙伴系统        |
| `buddy_alloc_pages(size_t n)`                    | 分配 n 页（自动向上取 2 的幂次） |
| `buddy_free_pages(struct Page *base, size_t n)`  | 释放 n 页并自动合并空闲块      |
| `buddy_nr_free_pages()`                          | 统计剩余空闲页数            |
| `buddy_check()`                                  | 自动测试与验证函数           |

---

## 🧰 调试辅助函数

| 函数                            | 功能                      |
| ----------------------------- | ----------------------- |
| `print_buddy_levels()`        | 打印伙伴树每层状态（节点数、空闲块数、块大小） |
| `dump_buddy_state()`          | 输出当前伙伴系统全局信息            |
| `validate_tree_consistency()` | 验证树的逻辑一致性               |
| `set_subtree_full()`          | 递归将子树设为空闲状态             |
| `clear_subtree_zero()`        | 清除子树中所有已分配节点的空闲标志       |

---

## 🧪 测试用例

本模块包含完整的自检测试逻辑：

### ✅ `basic_buddy_check()`

验证基本分配与释放行为：

* 单页多次分配、分裂验证
* 单页逐步释放与伙伴合并
* 多页块（4页）分配与释放
* 树层级输出可视化验证

### ✅ `buddy_edge_case_test()`

验证边界与异常情况：

* 分配最大块（占满整个内存）
* 分配失败（内存耗尽）
* 全部释放后树恢复初始状态

---


## 🧱 错误处理机制

| 错误类型      | 检查点                           | 处理方式            |
| --------- | ----------------------------- | --------------- |
| 非 2 的幂次页数 | `fixsize()`                   | 自动向上取整          |
| 分配空间不足    | `buddy_alloc_pages()`         | 返回 `NULL` 并输出提示 |
| 非法释放地址    | `buddy_free_pages()`          | 调用 `panic()` 报错 |
| 树结构不一致    | `validate_tree_consistency()` | 触发断言            |

---

## 🧑‍💻 内核集成接口

本模块实现了标准的 `pmm_manager` 接口：

```c
const struct pmm_manager buddy_pmm_manager = {
    .name = "buddy_system_pmm_manager",
    .init = buddy_init,
    .init_memmap = buddy_init_memmap,
    .alloc_pages = buddy_alloc_pages,
    .free_pages = buddy_free_pages,
    .nr_free_pages = buddy_nr_free_pages,
    .check = buddy_check,
};
```

这使得该模块可以无缝替换 uCore 或其他 OS 实验框架中的默认物理页分配器。

---

## 🧠 设计优点总结

* 🚀 **高性能**：O(log n) 分配/释放
* 🧩 **自动合并**：减少碎片
* 🔍 **可视化调试输出**：辅助验证正确性
* 🧱 **接口标准化**：兼容 PMM 框架
* 💾 **容错机制完善**：边界检查与断言保护

---

## 🧪 测试结果汇总

| 测试项目         | 状态   |
| ------------ | ---- |
| 单页分配与释放      | ✅ 通过 |
| 多页分配与释放      | ✅ 通过 |
| 边界情况（最大块、耗尽） | ✅ 通过 |
| 树一致性检查       | ✅ 通过 |
| 空闲页统计        | ✅ 正确 |

---

## 📎 附录

### 🔢 层级状态统计格式

```
层 <level>: 节点数=<num_nodes>, 空闲块数=<free_blocks>, 每块大小=<block_size>页
```

例如：

```
层 3: 节点数=8, 空闲块数=6, 每块大小=2048页
```

---

### 🔍 调试建议

* 若释放后层级空闲数不恢复，应检查：

  * `set_subtree_full()` 是否递归正确；
  * `index_to_offset()` 与 `offset_to_index()` 的偏移映射；
  * 父节点合并条件中 `left_longest == right_longest == size/2` 是否触发。

---

**结论：**

> 本实现完全覆盖了伙伴系统的核心逻辑、树结构维护、空闲块合并、调试诊断与边界测试，是一个功能完备、性能优良的内核物理内存管理子系统。

---
